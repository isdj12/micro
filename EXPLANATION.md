# Подробное объяснение работы кастомного загрузчика ESP32

## 1. Что такое загрузчик (Bootloader) в ESP32?

Загрузчик ESP32 - это специальная программа, которая выполняется **ПЕРЕД** запуском вашего основного приложения. Он находится в отдельной области флеш-памяти и отвечает за:
- Инициализацию аппаратуры
- Выбор, какое приложение запускать (Factory, OTA_0, OTA_1)
- Загрузку выбранного приложения в RAM
- Передачу управления приложению

## 2. Архитектура памяти ESP32 (согласно partitions.csv)

```
Адрес      Размер      Назначение
─────────────────────────────────────────
0x9000     0x5000      NVS (Non-Volatile Storage) - настройки
0xe000     0x2000      OTA Data - информация о выбранном OTA разделе
0x10000    0x1000      PHY Init - параметры WiFi/BT
0x20000    0x100000    Factory - основное приложение (1 МБ)
0x120000   0x100000    OTA_0 - первое OTA приложение (1 МБ)
0x220000   0x100000    OTA_1 - второе OTA приложение (1 МБ)
```

**Важно:** Загрузчик читает раздел `otadata` (0xe000), чтобы узнать, какое приложение запускать. Если там записано "OTA_1", загрузчик загружает приложение из адреса 0x220000.

## 3. Как работает стандартный загрузчик ESP32

1. **Сброс микроконтроллера** (Reset)
2. **1st Stage Bootloader** (в ROM, неизменяемый) - базовая инициализация
3. **2nd Stage Bootloader** (в флеш-памяти, можно модифицировать) - выбор приложения
4. **Загрузка приложения** из выбранного раздела
5. **Запуск приложения**

## 4. Что делает наш кастомный загрузчик?

Мы модифицируем **2nd Stage Bootloader**, добавляя проверку кнопки **ДО** выбора приложения.

### Последовательность работы:

```
1. ESP32 включается/перезагружается
   ↓
2. 1st Stage Bootloader (ROM) инициализирует базовую аппаратуру
   ↓
3. 2nd Stage Bootloader начинает работу
   ↓
4. ⚡ ВЫПОЛНЯЕТСЯ НАША ФУНКЦИЯ bootloader_after_init() ⚡
   ↓
5. Проверка: нажата ли кнопка на GPIO 18?
   ├─ ДА → Стираем otadata → Загрузчик выберет Factory
   └─ НЕТ → Продолжаем как обычно → Загрузчик выберет последний OTA
   ↓
6. Стандартный загрузчик читает otadata и загружает приложение
   ↓
7. Приложение запускается
```

## 5. Детальный разбор кода hooks.c

### Функция: `bootloader_after_init()`

Это **специальная функция-хук**, которую ESP-IDF вызывает автоматически, если она определена. Название функции фиксированное - ESP-IDF ищет её по имени.

### Шаг 1: Настройка GPIO 18 как входа

```c
esp_rom_gpio_pad_select_gpio(BOOT_BUTTON_GPIO);
```
- Выбирает GPIO 18 как обычный GPIO (не альтернативная функция)

```c
esp_rom_gpio_connect_in_signal(BOOT_BUTTON_GPIO, GPIO_IN_REG, false);
```
- Подключает GPIO 18 к регистру входа (GPIO_IN_REG)

```c
gpio_ll_input_enable(&GPIO, BOOT_BUTTON_GPIO);
gpio_ll_pullup_en(&GPIO, BOOT_BUTTON_GPIO);
gpio_ll_pulldown_dis(&GPIO, BOOT_BUTTON_GPIO);
```
- Включает GPIO как вход
- Включает внутреннюю подтяжку к питанию (Pull-Up)
- Отключает подтяжку к земле (Pull-Down)

**Почему Pull-Up?**
- Когда кнопка НЕ нажата: GPIO 18 = HIGH (3.3V через подтяжку)
- Когда кнопка НАЖАТА: GPIO 18 = LOW (0V, соединён с землёй)
- Это стандартная схема "активный низкий уровень"

### Шаг 2: Задержка для стабилизации

```c
esp_rom_delay_us(20000);  // 20 миллисекунд
```
- Даёт время сигналу устаканиться после включения подтяжки
- Предотвращает ложные срабатывания от переходных процессов

### Шаг 3: Проверка состояния кнопки

```c
if (gpio_ll_get_level(&GPIO, BOOT_BUTTON_GPIO) == 0)
```
- Читает уровень GPIO 18
- `0` = LOW = кнопка нажата (замкнута на землю)
- `1` = HIGH = кнопка не нажата (через подтяжку к питанию)

### Шаг 4: Если кнопка нажата - сброс OTA

```c
bootloader_common_ota_select_invalid();
```

**Что делает эта функция?**
- Стирает или помечает как невалидную информацию в разделе `otadata`
- Функция не требует параметров - она инвалидирует текущий активный OTA выбор
- После этого стандартный загрузчик не найдёт валидных OTA данных
- Загрузчик автоматически выберет **Factory** раздел как запасной вариант

**Почему это работает?**
Стандартный алгоритм загрузчика ESP32:
```
1. Попытка прочитать otadata
2. Если otadata валидна → загрузить указанное OTA приложение
3. Если otadata невалидна/отсутствует → загрузить Factory
```

### Шаг 5: Визуальная индикация (мигание LED)

```c
esp_rom_gpio_pad_select_gpio(2);
gpio_ll_output_enable(&GPIO, 2);

for(int i=0; i<5; i++) {
    gpio_ll_set_level(&GPIO, 2, 1);  // Включить LED
    esp_rom_delay_us(100000);        // 100 мс
    gpio_ll_set_level(&GPIO, 2, 0);  // Выключить LED
    esp_rom_delay_us(100000);        // 100 мс
}
```
- Настраивает GPIO 2 как выход (обычно это встроенный LED на ESP32)
- Мигает 5 раз по 100 мс
- Показывает пользователю, что кнопка была обнаружена

## 6. Почему используются ROM функции?

В загрузчике **НЕЛЬЗЯ** использовать обычные драйверы ESP-IDF (например, `driver/gpio.h`), потому что:
- Загрузчик работает **ДО** инициализации FreeRTOS
- Загрузчик работает **ДО** инициализации драйверов
- Загрузчик должен быть минимальным и быстрым

Поэтому используются:
- `esp_rom_*` - функции из ROM (Read-Only Memory, встроенные в чип)
- `gpio_ll_*` - Low-Level функции прямого доступа к регистрам
- `esp_rom_printf` - примитивный вывод в UART (без форматирования)

## 7. Как это всё собирается вместе?

### Структура проекта:

```
bootloader_components/my_boot_logic/
├── CMakeLists.txt  → Говорит сборщику: "Это компонент загрузчика"
└── hooks.c         → Наш код с функцией bootloader_after_init()
```

### CMakeLists.txt компонента:

```cmake
idf_component_register(SRCS "hooks.c"
                       REQUIRES bootloader_support log spi_flash micro-ecc efuse main)
```

**Что это значит?**
- `SRCS "hooks.c"` - компилировать файл hooks.c
- `REQUIRES bootloader_support` - нужна библиотека поддержки загрузчика
- `REQUIRES bootloader_common` - нужна библиотека с функцией `bootloader_common_ota_select_invalid()`

### Почему папка называется `bootloader_components`?

ESP-IDF автоматически ищет компоненты загрузчика в папке `bootloader_components/`. Всё, что там находится, компилируется **ВМЕСТО** стандартного загрузчика.

## 8. Процесс сборки

1. **Компиляция загрузчика:**
   - ESP-IDF находит `bootloader_components/my_boot_logic/`
   - Компилирует hooks.c вместе со стандартным загрузчиком
   - Создаёт `build/bootloader/bootloader.bin`

2. **Компиляция приложения:**
   - Компилирует `src/main.c`
   - Создаёт `build/my_bootloader_project.bin`

3. **Создание таблицы разделов:**
   - Читает `partitions.csv`
   - Создаёт `build/partition_table/partition-table.bin`

4. **Прошивка:**
   - Записывает всё в флеш-память ESP32

## 9. Сценарий использования

### Нормальная работа:
1. ESP32 загружается
2. `bootloader_after_init()` проверяет GPIO 18 → кнопка не нажата
3. Загрузчик читает otadata → находит OTA_1
4. Загружает приложение из раздела OTA_1 (0x220000)
5. Приложение запускается

### Сброс через кнопку:
1. Пользователь зажимает кнопку на GPIO 18
2. Пользователь нажимает Reset
3. ESP32 перезагружается
4. `bootloader_after_init()` проверяет GPIO 18 → кнопка нажата (LOW)
5. Функция стирает otadata
6. LED мигает 5 раз
7. Загрузчик читает otadata → не находит валидных данных
8. Загрузчик автоматически выбирает Factory раздел
9. Загружает приложение из Factory (0x20000)
10. Приложение запускается

## 10. Важные технические детали

### Почему задержка 20 мс?
- После включения подтяжки GPIO нужно время для стабилизации уровня
- 20 мс достаточно для большинства схем
- Слишком маленькая задержка → возможны ложные срабатывания

### Почему GPIO 18?
- Это стандартный GPIO, доступный на большинстве ESP32
- Не конфликтует с критическими сигналами (UART, SPI и т.д.)
- Можно использовать любой другой GPIO, изменив `#define BOOT_BUTTON_GPIO`

### Почему функция называется `bootloader_after_init()`?
- Это **фиксированное имя хука** в ESP-IDF
- ESP-IDF ищет эту функцию по имени через механизм слабых символов (weak symbols)
- Если функция найдена, она вызывается автоматически
- Если не найдена, ничего не происходит (стандартное поведение)

### Что такое "Custom 2nd Stage Bootloader"?
- **1st Stage** - встроен в ROM, неизменяемый
- **2nd Stage** - в флеш-памяти, можно модифицировать
- Мы модифицируем 2nd Stage, добавляя свою логику
- Это и есть "кастомный загрузчик"

## 11. Отладка и проблемы

### Проблема: Кнопка не работает
- Проверьте, что кнопка подключена правильно (GPIO 18 → кнопка → GND)
- Проверьте, что включён хук в menuconfig
- Проверьте логи через UART (должно быть сообщение "[BOOT HOOK]")

### Проблема: Загрузчик не переключается на Factory
- Проверьте, что функция `bootloader_common_ota_select_invalid()` доступна
- Проверьте версию ESP-IDF (функция может называться по-другому в старых версиях)
- Убедитесь, что otadata действительно стирается (можно проверить через esptool)

### Проблема: Проект не собирается
- Убедитесь, что включён хук в menuconfig: `Bootloader config → Bootloader hooks → Enable "bootloader_after_init" hook`
- Проверьте, что все зависимости указаны в CMakeLists.txt компонента
- Проверьте версию ESP-IDF (должна быть совместима с используемыми функциями)

## 12. Заключение

Этот проект демонстрирует **модификацию процесса загрузки** ESP32 на самом низком уровне. Мы вмешиваемся в работу загрузчика **ДО** запуска операционной системы и приложений, что позволяет:
- Реализовать аппаратный сброс OTA
- Добавить пользовательскую логику выбора приложения
- Создать recovery-режим через кнопку
- Получить полный контроль над процессом загрузки

Это и есть настоящий **Custom 2nd Stage Bootloader** - модификация стандартного загрузчика ESP32 под свои нужды.

